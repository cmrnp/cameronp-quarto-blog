{
  "hash": "48618b6801c9e1a9c52376ade0567355",
  "result": {
    "markdown": "---\ntitle: \"Making beautiful bar charts with ggplot\"\nauthor: \"Cameron Patrick\"\ndate: \"2020-03-15\"\ndraft: false\nslug: beautiful-bar-charts-ggplot\ncategories: [r, ggplot2]\nlastmod: '2020-03-15T13:30:00+11:00'\n---\n\n\n\n\n\n\nBar charts (or bar graphs) are commonly used, but they're also a simple type of\ngraph where the defaults in ggplot leave a lot to be desired. This is a\nstep-by-step description of how I'd go about improving them, describing the\nthought processess along the way. Every plot is different and the\ndecisions you make need to reflect the message you're trying to convey, so don't\ntreat this post as a recipe, treat it as some points to consider---and\nhopefully, a few tips that will help you achieve the look you want in your own plots.\n\nFor this blog post, I'm going to use the number of seats won by each political\nparty in the 2018 Victorian state election as an example. This data was obtained from\n[the Victorian Electoral Commission](https://www.vec.vic.gov.au/Results/State2018/Summary.html).\nVictorians may remember this election being described as a \"Danslide\", where\nLabor, led by Premier Daniel Andrews, won a clear majority of seats.\n\nHere's the data as an R command you can paste if you want to try making these\nplots yourself:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelection_data <- tribble(\n                    ~party, ~seats_won,\n       \"Australian Greens\",          3,\n  \"Australian Labor Party\",         55,\n                 \"Liberal\",         21,\n           \"The Nationals\",          6,\n        \"Other Candidates\",          3\n)\n```\n:::\n\n\nThe first decision to make when you're thinking of making a bar chart is whether\nyou'd be better off using a different type of plot entirely. Bar charts are most\nsuitable for displaying counts, percentages or other quantities where zero has a\nspecial meaning. If you make a bar chart, your axis should always start at zero,\nor the area of the bar gives a misleading visual impression. Other ways of\nrepresenting data, such as box plots or points with error bars, may be more\nappropriate for quantities\nwhere zero is not an important reference point. If you are representing time\nseries data (repeated observations made over time), a continuous line (perhaps\nwith points at the the times where observations were made) is almost always better\nthan a sequence of bars.\n\nThe second decision to make is which axis to put the categorical variable and\nwhich axis to put the numerical variable. Having the categories on the *y* axis\noften works best. It gives you more space when you have either\na large number of categories or categories with long labels. \n\nA lot of software either makes it more difficult to put categories on the *y*\naxis, or requires you to change a setting away from the default. This used to be\nthe case for ggplot, but as of version 3.3.0, you just need to tell it which\nvariable goes on which axis, and it will figure out the rest:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(election_data,\n       aes(x = seats_won, y = party)) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/barchart1-1.png){width=720}\n:::\n:::\n\n\nThe bar chart above is a good starting point, but quite a few things could be\nimproved. The order of the categories is a bit odd: from top to bottom, it's in\nreverse alphabetical order. This is the default in ggplot, but it is almost\nnever what you want. The easiest way\nto change this is to give the option `limits = rev` to the *y* axis scale\n(this is also new in ggplot version 3.3.0):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(election_data,\n       aes(x = seats_won, y = party)) +\n  geom_col() +\n  scale_y_discrete(limits = rev)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/barchart2-1.png){width=720}\n:::\n:::\n\n\nIn this particular case, alphabetical ordering isn't the best choice.\nIt's often best to order categories from most common to least common, or from\nmost to least in the variable you're displaying (e.g. most to least seats won).\nThere are two functions in the `forcats` package which can help with this: \n`fct_infreq` orders the level of a factor by how frequently they occur in the\ndata, and `fct_reorder` orders the level of a factor by the values of a\ndifferent variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nelection_data_sorted <- election_data %>%\n  mutate(party = fct_reorder(party, seats_won, .desc = TRUE))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(election_data_sorted,\n       aes(x = seats_won, y = party)) +\n  geom_col() +\n  scale_y_discrete(limits = rev)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/barchart3-1.png){width=720}\n:::\n:::\n\n\nIf I was doing exploratory data analysis, or making a quick plot to show a\ncolleague, I might stop at this point. But there is still plenty of room for\nimprovement. To start with, the axis labels are the variable names in our data\nframe, which is better than no labels at all, but are usually too brief or\njargon-laden for a wider audience. A good plot can be interpreted clearly with\nas little supporting information as possible---remember that a reader's eye will\nbe drawn to a large, colourful figure and ignore the paragraphs of text\nyou've written describing the full context.\n\nI've also changed the origin of the *x* axis so the bars are hard against the\naxis. Putting a blank space to the left of zero on a bar chart is something\nI've only ever seen in ggplot. It's caused by ggplot's standard rule of adding\n10% padding on either side of the biggest and smallest values plotted. You can\nturn it off by setting the `expand` option on the *x* axis scale.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(election_data_sorted,\n       aes(x = seats_won, y = party)) +\n  geom_col() +\n  scale_x_continuous(expand = expansion(mult = c(0, 0.1))) +\n  scale_y_discrete(limits = rev) +\n  labs(x = \"Number of seats won\",\n       y = \"Party\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/barchart4-1.png){width=720}\n:::\n:::\n\n\nThe grey background with white gridlines is a very distinctive ggplot default.\nSometimes it works well---it can reduce the visual noise of gridlines in complex\nplots---but in this case I would normally opt for a simpler. I often use\n`theme_bw` or `theme_minimal`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(election_data_sorted,\n       aes(x = seats_won, y = party)) +\n  geom_col() +\n  scale_x_continuous(expand = expansion(mult = c(0, 0.1))) +\n  scale_y_discrete(limits = rev) +\n  labs(x = \"Number of seats won\",\n       y = \"Party\") +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/barchart5-1.png){width=720}\n:::\n:::\n\n\nThe gridlines on the *x* axis are useful guides to the eye, but for a categorical\nvariable with only a few categories, the gridlines only introduce clutter. They\ncan be removed using the `theme` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(election_data_sorted,\n       aes(x = seats_won, y = party)) +\n  geom_col() +\n  scale_x_continuous(expand = expansion(mult = c(0, 0.1))) +\n  scale_y_discrete(limits = rev) +\n  labs(x = \"Number of seats won\",\n       y = \"Party\") +\n  theme_bw() +\n  theme(panel.grid.major.y = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/barchart6-1.png){width=720}\n:::\n:::\n\n\nThe default dark grey bars look a bit drab. You can choose a colour and give\nit as an option to `geom_col`. If you're like me, you'll probably try a couple\nof wrong things first: either passing the colour inside `aes()` (won't work,\nbecause the colour will be interpreted as data to plot) or using `colour` instead\nof `fill` (which changes the border colour instead). You can either use\na hexadecimal colour code (like in HTML), or one of [a number of built-in\ncolour names](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(election_data_sorted,\n       aes(x = seats_won, y = party)) +\n  geom_col(fill = \"darkorchid\") +\n  scale_x_continuous(expand = expansion(mult = c(0, 0.1))) +\n  scale_y_discrete(limits = rev) +\n  labs(x = \"Number of seats won\",\n       y = \"Party\") +\n  theme_bw() +\n  theme(panel.grid.major.y = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/barchart7-1.png){width=720}\n:::\n:::\n\n\nIn this context, it would be conventional to colour the bars based on the party\nbeing represented. Here I've set `fill = party`, then given a manual scale for\nthe fill based on party colours found on Wikipedia. I also disabled the legend,\nwhich isn't necessary in this instance---the party names are already next to the\nbars. I've also added a title and a caption indicating the source of the data;\nthese wouldn't normally be included in an academic publication but are a very\ngood idea for a plot which might be copied out of context.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(election_data_sorted,\n       aes(x = seats_won, y = party, fill = party)) +\n  geom_col() +\n  scale_x_continuous(expand = expansion(mult = c(0, 0.1))) +\n  scale_y_discrete(limits = rev) +\n  scale_fill_manual(breaks = c(\"Australian Labor Party\", \"Liberal\", \"The Nationals\",\n                               \"Australian Greens\", \"Other Candidates\"),\n                    values = c(\"#DE3533\", \"#0047AB\", \"#006644\",\n                               \"#10C25B\", \"#808080\")) +\n  labs(x = \"Number of seats won\",\n       y = \"Party\",\n       title = \"Victorian election 2018 lower house results\",\n       caption = \"Data source: Victorian Electoral Commission\") +\n  theme_bw() +\n  theme(panel.grid.major.y = element_blank(),\n        legend.position = \"off\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/barchart8-1.png){width=720}\n:::\n:::\n\n\nDepending on what you're trying to show with the graph, you may want to add\nannotations beyond what is contained in the original data. For example, you\ncould add a dashed line at 44 seats indicating the number required for a\nparty to form a majority government (which could slightly misleading, since the\nLiberal and National parties govern in coalition). In ggplot, you can pass\nspecific data to any `geom_` function; in this example I'm using `geom_vline`\nto draw the dashed line and `geom_text` to draw the label:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(election_data_sorted,\n       aes(x = seats_won, y = party, fill = party)) +\n  geom_vline(xintercept = 44, linetype = 2, colour = \"grey20\") +\n  geom_text(x = 45, y = 4, label = \"majority of\\nparliament\", \n            hjust = 0, size = 11 * 0.8 / .pt, colour = \"grey20\") +\n  geom_col() +\n  scale_x_continuous(expand = expansion(mult = c(0, 0.1))) +\n  scale_y_discrete(limits = rev) +\n  scale_fill_manual(breaks = c(\"Australian Labor Party\", \"Liberal\", \"The Nationals\",\n                               \"Australian Greens\", \"Other Candidates\"),\n                    values = c(\"#DE3533\", \"#0047AB\", \"#006644\",\n                               \"#10C25B\", \"#808080\")) +\n  labs(x = \"Number of seats won\",\n       y = \"Party\",\n       title = \"Victorian election 2018 lower house results\",\n       caption = \"Data source: Victorian Electoral Commission\") +\n  theme_bw() +\n  theme(panel.grid.major.y = element_blank(),\n        legend.position = \"off\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/barchart8b-1.png){width=720}\n:::\n:::\n\n\nFinally, another good option for representing the same type of data as a bar\nchart is a line with a point at the end. The point draws the eye to the end of\nthe line, which is the actual value being represented. You can create this in\nggplot by using a `geom_segment` to draw the line segment and `geom_point` to\ndraw the point. You also need to give `xend` and `yend` for `geom_segment` to\nwork---it's a general function for drawing line segments, not a specific\nfuncton for creating this type of plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(election_data_sorted,\n       aes(x = seats_won,\n           xend = 0,\n           y = party,\n           yend = party,\n           colour = party)) +\n  geom_segment() +\n  geom_point() +\n  scale_x_continuous(expand = expansion(mult = c(0, 0.1))) +\n  scale_y_discrete(limits = rev) +\n  scale_colour_manual(breaks = c(\"Australian Labor Party\", \"Liberal\", \"The Nationals\",\n                                 \"Australian Greens\", \"Other Candidates\"),\n                      values = c(\"#DE3533\", \"#0047AB\", \"#006644\",\n                                 \"#10C25B\", \"#808080\")) +\n  labs(x = \"Number of seats won\",\n       y = \"Party\",\n       title = \"Victorian election 2018 lower house results\",\n       caption = \"Data source: Victorian Electoral Commission\") +\n  theme(legend.position = \"off\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/barchart9-1.png){width=720}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
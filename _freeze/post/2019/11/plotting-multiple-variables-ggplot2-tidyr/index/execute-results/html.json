{
  "hash": "f79915cf36a653a6e57112c011d6b76a",
  "result": {
    "markdown": "---\ntitle: Plotting multiple variables at once using ggplot2 and tidyr\nauthor: Cameron Patrick\ndate: '2019-11-26'\ndraft: false\nslug: plotting-multiple-variables-ggplot2-tidyr\ncategories: [r, ggplot]\nsubtitle: ''\nsummary: 'In exploratory data analysis, it''s common to want to make similar\n  plots of a number of variables at once. Here is a way to achieve\n  this using R and `ggplot2`.'\nlastmod: '2019-11-26T11:00:00+11:00'\n---\n\n\nIn exploratory data analysis, it's common to want to make similar\nplots of a number of variables at once. For example, a randomised trial may\nlook at several outcomes, or a survey may have a large number of questions.\nHere is a way to achieve to plot them efficiently using R and `ggplot2`.\n\n\n\n\n\n\n\n\n## Pivoting longer: turning your variables into rows\n\n`ggplot2` doesn't provide an easy facility to plot multiple variables\nat once because this is usually a sign that [your data is not \"tidy\"](https://r4ds.had.co.nz/tidy-data.html). For example, in situations where you want\nto plot two columns on a graph as points with different colours, the two\ncolumns often really represent the same variable, and there is a hidden\ngrouping factor which distinguishes the data points you want to colour differently.\nThe usual answer in this scenario is that you\nshould restructure your data before plotting it. As a bonus, it will probably be\neasier to analyse your data in that form too.\n\nLikewise, if you want to split a plot into panels (or\nfacets, in `ggplot2`-speak),\nyou must plot a single response variable, with a grouping variable to indicate\nwhich panel the data should be plotted in.\nThe best structure for your data depends\non what you're trying to do with it, and in this situation, even if your data\nis in the right form for analysis, it may not be right for some of the plots you want\nto make.\n\nFortunately, restructuring your data into the right form is straightforward using the `tidyr`\npackage and the `pivot_longer()` function. In this example, I'm going to look at some\nmocked-up survey data, with six questions stored in variables `Q1` through `Q6`.\nThe original data frame looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(survey_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 300 × 7\n   group    Q1    Q2    Q3    Q4    Q5    Q6\n   <fct> <int> <int> <int> <int> <int> <int>\n 1 B         4     1     4     1     2     3\n 2 B         5     2     5     4     3     3\n 3 B         5     4     4     2     2     3\n 4 B         5     1     5     2     4     3\n 5 A         5     2     5     1     1     2\n 6 A         5     3     5     3     2     2\n 7 A         4     3     5     1     4     1\n 8 B         4     3     5     1     2     1\n 9 B         4     4     4     1     3     2\n10 B         4     4     5     2     5     4\n# ℹ 290 more rows\n```\n:::\n:::\n\n\nYou can convert this into a\nlonger data frame where the question number is stored in one column and the\nresponse is stored in a separate column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlonger_data <- survey_data %>%\n  pivot_longer(Q1:Q6, names_to = \"question\", values_to = \"response\")\nprint(longer_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,800 × 3\n   group question response\n   <fct> <chr>       <int>\n 1 B     Q1              4\n 2 B     Q2              1\n 3 B     Q3              4\n 4 B     Q4              1\n 5 B     Q5              2\n 6 B     Q6              3\n 7 B     Q1              5\n 8 B     Q2              2\n 9 B     Q3              5\n10 B     Q4              4\n# ℹ 1,790 more rows\n```\n:::\n:::\n\n\nYou don't even need to store the 'long form' data as a separate variable. If you're\nnot going to use the data in this form for anything else, it's\nsimpler to pipe the data straight into `ggplot2`. Here I use the `facet_wrap()`\nfunction to plot each question in a separate panel, so we can see the distribution\nof all of the questions at once:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurvey_data %>%\n  pivot_longer(Q1:Q6, names_to = \"question\", values_to = \"response\") %>%\n  ggplot(aes(x = response)) +\n  geom_bar() +\n  facet_wrap(vars(question), ncol = 3) +\n  labs(x = \"Response (on a 1 to 5 scale)\", y = \"Number of respondents\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/panel-plot-1.png){width=720}\n:::\n:::\n\n\nYou can use `question` as a factor anywhere else you would use a categorical\nvariable with ggplot. For example, you can make some box plots:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurvey_data %>%\n  pivot_longer(Q1:Q6, names_to = \"question\", values_to = \"response\") %>%\n  ggplot(aes(y = response, x = question)) +\n  geom_boxplot() +\n  labs(x = \"Question\", y = \"Response (on a 1 to 5 scale)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/box-plot-1.png){width=720}\n:::\n:::\n\n\nThis is also a nice demonstration of how box plots are rarely the best way to\npresent Likert scale data.\n\nAny other variables are retained after you call `pivot_longer()`, so you can\ne.g. compare the responses to survey questions based on a demographic variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurvey_data %>%\n  pivot_longer(Q1:Q6, names_to = \"question\", values_to = \"response\") %>%\n  ggplot(aes(x = response, colour = group)) +\n  facet_wrap(vars(question), ncol = 3) +\n  geom_point(stat = \"count\") +\n  geom_line(stat = \"count\") +\n  labs(x = \"Response (on a 1 to 5 scale)\", y = \"Number of respondents\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/line-plot-1.png){width=720}\n:::\n:::\n\n\nBy default, R will sort the levels of factors alphabetically. This isn't always\nwhat you want in this situation---often the order of the variables in your data\nframe has some meaning to it. The `fct_inorder()` function allows you to reorder\nlevels of a factor in the order of first appearance in the file. If you use that\nwith the column produced by `pivot_longer()`, the factor will be ordered by the\norder of the columns in the original data frame.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
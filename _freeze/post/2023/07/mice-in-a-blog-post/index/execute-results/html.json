{
  "hash": "f513b3f0f8dda945caa0edc9d1c8ba29",
  "result": {
    "markdown": "---\ntitle: \"Dirty imputation done dirt cheap: implementing Multiple Imputation by Chained Equations in one blog post\"\nauthor: \"Cameron Patrick\"\ndate: \"2023-07-31\"\ndraft: false\ncategories: [r, statistics]\ncsl: apa.csl\nbibliography: mice.yaml\nformat:\n  html:\n    toc: true\nabstract: |\n  An attempt to understand in detail how Multiple Imputation by Chained\n  Equations (MICE) works, by coding it up from scratch.\nexecute:\n  echo: true\n  message: false\n  warning: false\nfig-width: 5.5\nfig-height: 3.5\nfig-dpi: 130\n---\n\n\n## Introduction\n\nCoding up an algorithm is a great way to make sure you really understand how the details work. In this post I'm going to implement multiple imputation and the MICE algorithm [@vanbuuren2007multipleimputationdiscrete], albeit in much simplified form: only considering missing data in numeric variables, only using Normal-distribution Bayesian linear regression to generate the imputed data, no concerns about robustness of the code for production purposes.\n\nIf the standard version of this method is called MICE, think of this as a smaller, cuter, maybe slightly endangered variation. Perhaps a fat-tailed dunnart.\n\n![Fat-tailed dunnart in Queensland, Australia. Image by [Bernard Dupont, sourced from Wikimedia Commons (CC-SA licence)](https://commons.wikimedia.org/wiki/File:Fat-tailed_Dunnart_(Sminthopsis_crassicaudata)_(9998321085).jpg).](fat-tailed-dunnart.jpg){width=715px}\n\n## Bayesian linear regression\n\nWe will be imputing each individual variable with missing data using Bayesian linear regression with uninformative Jeffreys priors. For this choice of prior, the posterior distribution of the parameters has an easily computable analytic distribution. This approach is explained in detail in @gelman2014bayesiandataanalysis, chapter 14.\n\nThe regression equation is given by $E(Y|X) = X^T \\beta$, where $Y$ is a column vector of observations, $X$ is the design matrix, and $\\beta$ is a column vector of regression coefficients. We assume independent normally distributed errors with equal standard deviation: $Y|X \\sim \\mathrm{MVN}(X^T \\beta, \\sigma^2 I)$. In other words, the usual classical linear regression.\n\n### Obtaining parameter estimates from Jeffreys priors\n\nThe simplest choice of prior (in terms of easily obtaining a posterior distribution) is the Jeffreys prior, which is an improper uninformative prior: uniform over $(\\beta, \\log \\sigma)$. In this case, the posterior distribution of $\\beta$ is multivariate normal: $\\beta \\sim \\mathrm{MVN}(\\hat\\beta, V)$. Here $\\hat\\beta = (X^T X)^{-1} X^T Y$ is the frequentist maximum likelihood estimate (ordinary least squares regression) and $V = \\sigma^2 (X^T X)^{-1}$ is the usual linear regression variance-covariance matrix.\n\nThe posterior distribution of $\\sigma^2$ is $\\mathrm{Inverse-}\\chi^2(n-k, s^2)$ where $s^2$ is the standard frequentist estimate of the residual variance [@gelman2014bayesiandataanalysis, p. 355]. This scaled inverse $\\chi^2$ distribution was a new one to me[^ugbayes]. We say a random variable $U \\sim \\mathrm{Inverse-}\\chi^2(\\nu, \\mu)$ if $V \\sim \\chi^2(\\nu)$ and $U = \\nu\\mu/V$ [@gelman2014bayesiandataanalysis, p. 581].\n\n[^ugbayes]: Well, I probably met it and forgot about it long ago in undergrad Bayes class.\n\nWe could just use the built-in R `lm` function, but it's been a long time since I last implemented linear regression from scratch, so thought I'd give it a go here. If you're not interested in seeing this, [skip to the section about drawing from the posterior distribution](#sec-drawing-posterior).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# estimate_bayes_lm_jeffreys(Y, X): obtain Bayesian linear regression parameter\n# estimates from design matrix X and observations Y, using a Jeffreys prior.\n# Should produce the same output as lm().\nestimate_bayes_lm_jeffreys <- function(Y, X) {\n  stopifnot(is.matrix(X) & is.numeric(X) & !any(is.na(X)))\n  stopifnot(is.vector(Y) & is.numeric(Y) & !any(is.na(Y)))\n  stopifnot(nrow(X) == length(Y))\n\n  # crossprod(X) computes X^T X\n  # solve(X, Y) computes X^-1 Y\n  # Some fiddling is needed since we want our vector outputs to be R vectors,\n  # not R matrices\n  xtx <- crossprod(X)\n  beta <- as.vector(solve(xtx, t(X) %*% Y))\n  df <- nrow(X) - ncol(X)\n  s2 <- as.vector(crossprod(Y - X %*% beta) / df)\n  V <- s2 * solve(xtx)\n\n  # Attach variable names to regression coefficients\n  names(beta) <- colnames(X)\n\n  res <- list(X = X, Y = Y, beta = beta, V = V, df = df, s2 = s2)\n  class(res) <- \"bayeslm\"\n  res\n}\n```\n:::\n\n\nThis function expects a vector of observations and a design matrix containing the predictors, but that's not very convenient in practice. To make this easier to use, let's write a function that implements a formula interface closer to the standard R `lm` function. This takes advantage of two base R functions: `model.frame` takes a model formula and prepares a data frame with the variables mentioned in it, with the outcome variable first, omitting missing values, and providing the option to only include a subset of rows; and `model.matrix` which creates a design matrix from a formula and a data frame, adding an intercept and creating dummy variables for categorical variables if needed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbayes_lm <- function(\n  formula, data = NULL, subset = NULL, \n  na.action = getOption(\"na.action\"),\n  estimator = estimate_bayes_lm_jeffreys\n) {\n  if (is.character(na.action)) {\n    na.action <- get(na.action)\n  }\n  mf_args <- list(formula = formula, data = data,\n                  subset = subset, na.action = na.action)\n  model_frame <- do.call(stats::model.frame, mf_args)\n  model_matrix <- model.matrix(formula, model_frame)\n  estimator(model_frame[[1]], model_matrix)\n}\n```\n:::\n\n\nTo make the objects that we've created behave a bit more like standard R `lm` objects, we can implement some S3 methods for our new type of object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef.bayeslm <- function(m) m$beta\nvcov.bayeslm <- function(m) m$V\nsigma.bayeslm <- function(m) sqrt(m$s2)\ndf.residual.bayeslm <- function(m) m$df\nresid.bayeslm <- function(m) (m$Y - m$X %*% t(m$beta))\nprint.bayeslm <- function(m, digits = 3) {\n  cat(\"Coefficients:\\n\")\n  print(format(m$beta, digits = digits), quote = FALSE)\n}\nsummary.bayeslm <- function(m)\n  data.frame(\n    term = names(m$beta),\n    estimate = m$beta,\n    std.error = sqrt(diag(m$V)),\n    row.names = seq_along(m$beta)\n  )\n```\n:::\n\n\nLet's make sure this works as expected, using the `penguins` data from the `palmerpenguins` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\ndata(penguins)\n```\n:::\n\n\nFit two models, one using `lm` and one using `bayes_lm`, to predict bill length from flipper length:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins_lm <- lm(\n  bill_length_mm ~ flipper_length_mm , \n  data = penguins\n)\npenguins_blm <- bayes_lm(\n  bill_length_mm ~ flipper_length_mm,\n  data = penguins\n)\n```\n:::\n\n\nCheck that the regression coefficients and standard errors are the same for both models:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(penguins_lm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = bill_length_mm ~ flipper_length_mm, data = penguins)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-8.5792 -2.6715 -0.5721  2.0148 19.1518 \n\nCoefficients:\n                  Estimate Std. Error t value Pr(>|t|)    \n(Intercept)       -7.26487    3.20016   -2.27   0.0238 *  \nflipper_length_mm  0.25477    0.01589   16.03   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.126 on 340 degrees of freedom\n  (2 observations deleted due to missingness)\nMultiple R-squared:  0.4306,\tAdjusted R-squared:  0.4289 \nF-statistic: 257.1 on 1 and 340 DF,  p-value: < 2.2e-16\n```\n:::\n\n```{.r .cell-code}\nsummary(penguins_blm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               term   estimate  std.error\n1       (Intercept) -7.2648678 3.20015684\n2 flipper_length_mm  0.2547682 0.01588914\n```\n:::\n:::\n\n\n### Drawing from the posterior predictive distribution {#sec-drawing-posterior}\n\nTo sample from the posterior predictive distribution, we use a two-stage process. First, draw from the posterior distribution of the parameters (regression coefficients and residual variance). As previously discussed, the regression coefficients have a multivariate normal distribution and the residual variance has an $\\mathrm{Inverse-}\\chi^2$ distribution. Secondly, draw posterior predictions conditional on those parameter estimates, using $Y|X,\\beta,\\sigma^2 \\sim \\mathrm{N}(X^T \\beta, \\sigma^2)$.\n\nThe function below does the first stage, drawing from the posterior distribution of the model parameters. It doesn't require the model to be fit using the code from above, this should work for any `lm` model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw_bayes_lm_params <- function(m, ndraw = 1) {\n  stopifnot(inherits(m, c(\"lm\", \"bayeslm\")))\n  stopifnot(is.numeric(ndraw) & length(ndraw) == 1 & ndraw >= 1)\n\n  # Draw from the posterior distribution of parameters\n  draw_beta <- mvtnorm::rmvnorm(ndraw, coef(m), vcov(m))\n  df <- df.residual(m)\n  draw_sigma <- sigma(m) * sqrt(df / rchisq(ndraw, df))\n  list(beta = draw_beta, sigma = draw_sigma)\n}\n```\n:::\n\n\n\n\nTo get some idea if this is working, let's plot the posterior distribution of our parmaeters. They look like what we might expect - normally distributed about the parameter estimates shown above. In fact the distribution of sigma looks far closer to normal than I expected, given it's actually a scaled inverse Chi squared distribution!\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(12345)\npenguins_blm %>%\n  draw_bayes_lm_params(1000) %>%\n  map(as_tibble) %>%\n  bind_cols() %>%\n  rename(sigma = value) %>%\n  pivot_longer(everything(), names_to = \"var\", values_to = \"value\") %>%\n  ggplot(aes(x = value)) +\n  stat_slabinterval(normalize = \"panels\") +\n  scale_y_continuous(breaks = NULL) +\n  facet_wrap(vars(var), scales = \"free\") +\n  labs(x = \"value\", y = \"density\") +\n  panel_border()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/posterior-param-dists-1.png){fig-align='center' width=715}\n:::\n:::\n\n\nThe posterior regression coefficients for flipper length and intercept are negatively correlated, as we might expect:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(54321)\npenguins_blm %>%\n  draw_bayes_lm_params(100) %>%\n  pluck(\"beta\") %>%\n  as_tibble() %>%\n  ggplot(aes(x = flipper_length_mm, y = `(Intercept)`)) +\n  geom_point(pch = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/posterior-param-corr-1.png){fig-align='center' width=715}\n:::\n:::\n\n\nNow we're more confident that seemed to work, we can write another function to estimate the posterior predictive distribution of a bunch of new observations, given their X values. This works by drawing a set of $\\beta$ parameters, calculating Y values from those, and adding some normally-distributed random noise based on $\\sigma^2$. This results in the model-predicted distribution of new observations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw_bayes_lm_ppred <- function(m, X = m$X, ndraw = 1) {\n  stopifnot(inherits(m, c(\"lm\", \"bayeslm\")))\n  stopifnot(is.matrix(X) & is.numeric(X) & !any(is.na(X)))\n  stopifnot(ncol(X) == length(coef(m)))\n\n  params <- draw_bayes_lm_params(m, ndraw = ndraw)\n  X %*% t(params$beta) + matrix(\n    rnorm(nrow(X) * ndraw, 0, rep(params$sigma, each = nrow(X))),\n    nrow = nrow(X)\n  )\n}\n```\n:::\n\n\nTo demonstrate this in action, the plot below shows a subset of the penguins data, the regression line (grey), the observed data (solid blue circles), and 10 draws from the posterior predictive distribution (hollow red circles):\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nset.seed(42)\npenguins_subset <- penguins %>%\n  select(bill_length_mm, flipper_length_mm) %>%\n  drop_na() %>%\n  sample_n(30)\npenguins_subset_ppred <- draw_bayes_lm_ppred(\n  penguins_blm, \n  model.matrix(bill_length_mm ~ flipper_length_mm, data = penguins_subset), \n  ndraw = 10\n)\npenguins_subset_ppred_dat <- penguins_subset_ppred %>%\n  as_tibble(.name_repair = \"unique\") %>%\n  bind_cols(flipper_length_mm = penguins_subset$flipper_length_mm) %>%\n  pivot_longer(-flipper_length_mm, \n               names_to = \"rep\",\n               values_to = \"bill_length_mm\")\nggplot(penguins_subset, aes(x = flipper_length_mm, y = bill_length_mm)) +\n  geom_abline(intercept = coef(penguins_blm)[1],\n              slope = coef(penguins_blm)[2],\n              colour = \"black\",\n              linewidth = 1.5,\n              alpha = 0.5) +\n  geom_point(colour = \"dodgerblue4\", size = 4, alpha = 0.5, stroke = NA) +\n  geom_point(colour = \"firebrick4\", size = 1, pch = 1,\n             data = penguins_subset_ppred_dat, alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/posterior-ppred-plot-1.png){fig-align='center' width=715}\n:::\n:::\n\n\nIf we only had missing values in one variable, we would be at the point of producing imputed datasets now. But real-life missing data problems tend to have missing data in multiple variables, so we will need to use an iterative method to generate imputations for all variables.\n\n## Creating imputations by chained equations\n\nNow we have a function to draw from the posterior of a Bayesian linear regression, we can apply it iteratively to each incomplete variable to produce multiple imputed datasets. The MICE algorithm works something like this:\n\n1. Create an initial dataset with complete values for all variables. (In this simple implementation, I will replace all missing values with the mean of the observed values.)\n\n2. For each incomplete variable, take the most recent iteration and fit an appropriate linear regression to the subset of the observations for which that variable has been observed. Draw from the posterior predictive distribution to fill in new values for the observations where that variable was not observed.\n\n3. Repeat step 2 a fixed number of terms (`iter` in our example implementation).\n\n4. Repeat the entire procedure (steps 1 to 3) `m` times to produce `m` imputed datasets.\n\nThis section of the blog will reimplement a simple version of this algorithm, which I have named dunnart (a smaller, cuter ~~MICE~~ mouse). It only supports imputation of numerical variables, and only using linear regression. Rather than the comprehensive inputs `mice` uses to control the imputation algorithm, the main input will be a list of regression formulas, one for each variable to impute.\n\n### The first iteration of imputed data\n\nFor the initial iteration of imputation, we will replace all missing values with the mean of the non-missing values. The function below does some error checking (ensures that at it is being called on a numeric variable with at least one missing value and at least one observed value) and then uses `replace_na()` from the `tidyr` package to do the actual work.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunnart_initial_imputation_for_var <- function(x) {\n  stopifnot(is.vector(x) & is.numeric(x))\n  stopifnot(!all(is.na(x)))\n  stopifnot(any(is.na(x)))\n\n  # replace missing values with the mean of the non-missing values\n  replace_na(x, mean(x, na.rm = TRUE))\n}\n```\n:::\n\n\nThe function below applies `dunnart_initial_imputation_for_var` to several variables in a data frame, selected based on them appearing as outcome variables in a list of regression formulas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunnart_initial_imputation_for_df <- function(dat, formula_list) {\n  stopifnot(is.data.frame(dat))\n  stopifnot(is.list(formula_list))\n\n  # find the outcome variable in each formula in formula_list\n  vars <- map_chr(formula_list, \\(f) all.vars(f)[1])\n\n  # do the initial imputation for each of those variables\n  mutate(dat, across(all_of(vars), dunnart_initial_imputation_for_var))\n}\n```\n:::\n\n\n### Creating subsequent iterations\n\nThe function below, `dunnart_impute_var`, is really the heart of the multiple imputation algorithm. It takes the original data frame with incomplete data `dat_orig`, the current working iteration of the imputed data `dat_cur`, and a regression formula `formula` to specify which predictors are used for the imputation. There's an additional flag `verbose` which controls how much diagnostic information is printed to the console (the default emulates the output of `mice` as it runs).\n\nThe steps are as follows:\n\n1. Determine which variable we're imputing, based on the outcome variable of the regression formula.\n\n2. Determine which observations we need to impute (and the inverse: which observations we should fit the regression model to), based on the original incomplete data frame.\n\n3. Fit a linear regression using the provided model formula to the observations of current imputation-in-progress data frame chosen above.\n\n4. Draw from the posterior predictive distribution of the observations which were not used to fit that model and use them to replace the corresponding observations of the variable we're imputing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunnart_impute_var <- function(dat_orig, dat_cur, formula, verbose = TRUE) {\n  stopifnot(is.data.frame(dat_orig) & is.data.frame(dat_cur) &\n            inherits(formula, \"formula\"))\n \n  # find the variable we're imputing\n  out_var <- all.vars(formula)[1]\n  if (verbose >= 2) {\n    cat(\"    imputing using\", deparse1(formula), \"\\n\")\n  } else if (verbose >= 1) {\n    cat(\" \", out_var)\n  }\n\n  # which rows have missing data in the original data frame?\n  miss_rows <- is.na(dat_orig[[out_var]])\n\n  # fit a regression model to the rows that didn't have missing values in\n  # the original data\n  mod <- lm(formula, data = dat_cur[!miss_rows, ])\n\n  # draw predictions for the rows with missing values\n  mf <- model.frame(formula, data = dat_cur[miss_rows, ])\n  mat <- model.matrix(formula, data = mf)\n  dat_cur[miss_rows, out_var] <- draw_bayes_lm_ppred(mod, mat)\n\n  # return the updated data frame\n  dat_cur\n}\n```\n:::\n\n\nTo get one complete iteration of the MICE algorithm for a single imputed dataset, we need to apply the above function to each variable we need to impute. This is done using the `reduce()` function from the `purrr` package, which repeatedly applies a function to its own output (the current imputed dataset, `dat_cur`) and a list of new values (the regression model formulas for the variables to impute, `formula_list`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunnart_impute_iterate <- function(\n  dat_orig, dat_cur, formula_list, verbose = TRUE, j = NA, m = NA\n) {\n  stopifnot(is.data.frame(dat_orig) & is.data.frame(dat_cur) &\n            is.list(formula_list) & all(!is.na(dat_cur)))\n\n  if (verbose >= 2) {\n    cat(\"  imputation\", j, \"of\", m, \"\\n\")\n  } else if (verbose >= 1) {\n    cat(\"  [\", j, \"/\", m, \"]\")\n  }\n\n  dat_out <- reduce(\n    formula_list,\n    \\(dat, form) dunnart_impute_var(dat_orig, dat, form, verbose),\n    .init = dat_cur\n  )\n\n  if (verbose == 1) {\n    cat(\"\\n\")\n  }\n\n  dat_out\n}\n```\n:::\n\n\n### Creating multiple imputed datasets\n\nThe functions we have above all operate on a single imputed dataset, but we want to produce multiple imputed datasets. The `dunnart_multiple_impute_iterate` function applies the `dunnart_impute_iterate` function to a list of imputed datasets using the `map2()` function from the `purrr` package. The code is slightly messier than ideal because we pass through some additional information (the imputation index and the total number of imputations) to allow progress reporting in verbose mode.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunnart_multiple_impute_iterate <- function(\n  data, imp_out, formula_list, verbose = TRUE, i = NA, iter = NA\n) {\n  if (verbose >= 1) {\n    cat(\"imputation iteration\", i, \"of\", iter, \"\\n\")\n  }\n\n  # apply one imputation step to each imputed dataset\n  map2(\n    imp_out,\n    seq_along(imp_out),\n    \\(dat_cur, j) dunnart_impute_iterate(\n      data, dat_cur, formula_list, verbose = verbose,\n      j = j, m = length(imp_out)\n    )\n  )\n}\n```\n:::\n\n\nFinally, putting it all together: `dunnart_impute()` is our equivalent of the `mice()` function, taking an incomplete dataset, a list of model formulas, the number of imputed datasets and number of iterations to run, and returning the multiple imputed output. Most of the code here is error checking. The two statements that actually do the work are the ones beginning `imp_out <- map(...)` to create the initial imputation, and `all_imps <- accumulate(...)` to create the subsequent iterations by repeatedly calling `dunnart_multiple_impute_iterate()`. Finally we create an object of class `dunnart` to hold the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunnart_impute <- function(\n  data, formula_list, m = 5, iter = 10, verbose = TRUE\n) {\n  stopifnot(is.data.frame(data))\n  stopifnot(is.list(formula_list) & \n            all(map_lgl(formula_list, \\(x) inherits(x, \"formula\"))))\n  stopifnot(is.numeric(m) & length(m) == 1 & !is.na(m) & m >= 1)\n  stopifnot(is.numeric(iter) & length(iter) == 1 & !is.na(iter) & iter >= 0)\n  stopifnot((is.logical(verbose) | is.numeric(verbose)) & \n            length(verbose) == 1 & !is.na(verbose))\n\n  # set up initial imputations (mean imputation)\n  if (verbose >= 1) {\n    cat(\"generating\", m, \"initial imputations\\n\")\n  }\n  imp_out <- map(\n    seq_len(m), \n    \\(x) dunnart_initial_imputation_for_df(data, formula_list)\n  )\n\n  # check for any NA values after initial imputation, signifying that some\n  # variables with missing data do not have imputation formulas provided\n  if (any(map_lgl(imp_out, \\(dat) any(is.na(dat))))) {\n    stop(\"NAs found after initial imputation step - fix imputation formulas\")\n  }\n\n  # repeat the imputation iteration step 'iter' times\n  all_imps <- accumulate(\n    seq_len(iter),\n    \\(imp, i) dunnart_multiple_impute_iterate(\n      data, imp, formula_list, verbose = verbose, i = i, iter = iter\n    ),\n    .init = imp_out\n  )\n\n  # return results\n  res <- list(\n    m = m,\n    iter = iter,\n    formula_list = formula_list,\n    orig_data = data,\n    iterations = all_imps,\n    imputations = all_imps[[iter + 1]]\n  )\n  class(res) <- \"dunnart\"\n  res\n}\n```\n:::\n\n\n### Functions for extracting imputed data\n\nDefine a `print` method for `dunnart` objects so that we see a nice summary instead of all of the imputed data spewed to the console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.dunnart <- function(obj) {\n  cat(\"'dunnart' multiple imputation object:\\n\",\n      \" -\", obj$m, \"imputed datasets\\n\",\n      \" -\", obj$iter, \"iterations\\n\",\n      \" -\", nrow(obj$orig_data), \"observations of\",\n      ncol(obj$orig_data), \"variables\\n\")\n}\n```\n:::\n\n\nThe `dunnart_complete_long` function does something similar to the `complete` function in `mice`, returning a long-form data frame with all imputed datasets, containing a `.imp` variable identifying the imputation and a `.id` variable identifying the row within the imputation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunnart_complete_long <- function(obj, iteration = obj$iter) {\n  stopifnot(inherits(obj, \"dunnart\"))\n  stopifnot(is.numeric(iteration) & length(iteration) == 1)\n  stopifnot(iteration >= 0 & iteration <= obj$iter)\n\n  bind_rows(\n    map(obj$iterations[[iteration + 1]],\n        \\(dat) mutate(dat, .id = row_number(), .before = 1L,\n                      .by = all_of(NULL))),\n    .id = \".imp\"\n  ) %>%\n    mutate(.imp = as.numeric(.imp)) %>%\n    remove_rownames()\n}\n```\n:::\n\n\nThe `dunnart_all_iters_long()` function does similar, but includes all intermediate iterations of the imputation process. This will be used later to create trace plots to assess imputation convergence.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunnart_all_iters_long <- function(obj) {\n  stopifnot(inherits(obj, \"dunnart\"))\n  iters <- 0:obj$iter\n  bind_rows(\n    map(iters, \\(i) dunnart_complete_long(obj, i)) %>%\n      set_names(iters),\n    .id = \".iter\"\n  ) %>%\n    mutate(.iter = as.numeric(.iter))\n}\n```\n:::\n\n\n## Taking it for a test ride\n\nFor this example we'll use the `nhanes` data from the `mice` package. This dataset contains four variables: `age`, `bmi`, `hyp`, and `chl`; of which `age` is completely observed but all of the others contain missing values. The variable `hyp` is an indicator variable for a binary factor but we will treat it as if it's numeric for our imputation purposes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(nhanes, package = \"mice\")\n```\n:::\n\n\nThe code below calls the `dunnart_impute()` function to obtain 5 imputed datasets, using 10 iterations. Each variable is imputed using all other variables. Unlike in `mice`, we need to specify this by providing a full regression formula for each variable to be imputed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(314159)\nimp <- dunnart_impute(\n  nhanes,\n  list(\n    bmi ~ age + hyp + chl,\n    hyp ~ age + bmi + chl,\n    chl ~ age + bmi + hyp\n  ),\n  m = 5,\n  iter = 10\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ngenerating 5 initial imputations\nimputation iteration 1 of 10 \n  [ 1 / 5 ]  bmi  hyp  chl\n  [ 2 / 5 ]  bmi  hyp  chl\n  [ 3 / 5 ]  bmi  hyp  chl\n  [ 4 / 5 ]  bmi  hyp  chl\n  [ 5 / 5 ]  bmi  hyp  chl\nimputation iteration 2 of 10 \n  [ 1 / 5 ]  bmi  hyp  chl\n  [ 2 / 5 ]  bmi  hyp  chl\n  [ 3 / 5 ]  bmi  hyp  chl\n  [ 4 / 5 ]  bmi  hyp  chl\n  [ 5 / 5 ]  bmi  hyp  chl\nimputation iteration 3 of 10 \n  [ 1 / 5 ]  bmi  hyp  chl\n  [ 2 / 5 ]  bmi  hyp  chl\n  [ 3 / 5 ]  bmi  hyp  chl\n  [ 4 / 5 ]  bmi  hyp  chl\n  [ 5 / 5 ]  bmi  hyp  chl\nimputation iteration 4 of 10 \n  [ 1 / 5 ]  bmi  hyp  chl\n  [ 2 / 5 ]  bmi  hyp  chl\n  [ 3 / 5 ]  bmi  hyp  chl\n  [ 4 / 5 ]  bmi  hyp  chl\n  [ 5 / 5 ]  bmi  hyp  chl\nimputation iteration 5 of 10 \n  [ 1 / 5 ]  bmi  hyp  chl\n  [ 2 / 5 ]  bmi  hyp  chl\n  [ 3 / 5 ]  bmi  hyp  chl\n  [ 4 / 5 ]  bmi  hyp  chl\n  [ 5 / 5 ]  bmi  hyp  chl\nimputation iteration 6 of 10 \n  [ 1 / 5 ]  bmi  hyp  chl\n  [ 2 / 5 ]  bmi  hyp  chl\n  [ 3 / 5 ]  bmi  hyp  chl\n  [ 4 / 5 ]  bmi  hyp  chl\n  [ 5 / 5 ]  bmi  hyp  chl\nimputation iteration 7 of 10 \n  [ 1 / 5 ]  bmi  hyp  chl\n  [ 2 / 5 ]  bmi  hyp  chl\n  [ 3 / 5 ]  bmi  hyp  chl\n  [ 4 / 5 ]  bmi  hyp  chl\n  [ 5 / 5 ]  bmi  hyp  chl\nimputation iteration 8 of 10 \n  [ 1 / 5 ]  bmi  hyp  chl\n  [ 2 / 5 ]  bmi  hyp  chl\n  [ 3 / 5 ]  bmi  hyp  chl\n  [ 4 / 5 ]  bmi  hyp  chl\n  [ 5 / 5 ]  bmi  hyp  chl\nimputation iteration 9 of 10 \n  [ 1 / 5 ]  bmi  hyp  chl\n  [ 2 / 5 ]  bmi  hyp  chl\n  [ 3 / 5 ]  bmi  hyp  chl\n  [ 4 / 5 ]  bmi  hyp  chl\n  [ 5 / 5 ]  bmi  hyp  chl\nimputation iteration 10 of 10 \n  [ 1 / 5 ]  bmi  hyp  chl\n  [ 2 / 5 ]  bmi  hyp  chl\n  [ 3 / 5 ]  bmi  hyp  chl\n  [ 4 / 5 ]  bmi  hyp  chl\n  [ 5 / 5 ]  bmi  hyp  chl\n```\n:::\n:::\n\n\n### Diagnostics\n\n#### Trace plots\n\nThe plot below shows the mean and standard deviation of the imputed values of each variable at each iteration of the imputation process. Each coloured line shows a different imputed dataset. The 'zeroth' iteration is the initial mean imputation step where all imputed datasets are the same. The subsequent iterations show that the imputations very quickly start 'mixing' well, resembling a low-resolution fuzzy caterpillar.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nmiss_rows <- nhanes %>%\n  mutate(.id = row_number()) %>%\n  pivot_longer(c(bmi, hyp, chl), names_to = \"var\", values_to = \"miss\") %>%\n  mutate(miss = is.na(miss))\n\ntrace_data <- dunnart_all_iters_long(imp) %>%\n  pivot_longer(c(bmi, hyp, chl), names_to = \"var\", values_to = \"value\") %>%\n  left_join(miss_rows, by = c(\".id\", \"var\")) %>%\n  filter(miss) %>%\n  summarise(\n    mean = mean(value),\n    sd = sd(value),\n    .by = c(.iter, .imp, var)\n  ) %>%\n  mutate(across(c(.iter, .imp), as.factor))\n\nplot_grid(\n  trace_data %>%\n    ggplot(aes(x = .iter, y = mean, colour = .imp, group = .imp)) +\n    geom_line() +\n    facet_wrap(~var, scales = \"free_y\") +\n    panel_border() +\n    theme(legend.position = \"off\"),\n  trace_data %>%\n    ggplot(aes(x = .iter, y = sd, colour = .imp, group = .imp)) +\n    geom_line() +\n    facet_wrap(~var, scales = \"free_y\") +\n    panel_border() +\n    theme(legend.position = \"off\"),\n  nrow = 2\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/trace-plot-1.png){fig-align='center' width=715}\n:::\n:::\n\n\n\n#### Distribution of imputed data\n\nIn the plot below, the blue circles show the original (completely observed data) and the red circles showing imputed values. We can see that the imputation for 'hyp' isn't ideal, with the original data only taking the values of 1 or 2, but imputed values being anywhere on the real line.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\ndunnart_complete_long(imp) %>%\n  pivot_longer(c(bmi, hyp, chl), names_to = \"var\", values_to = \"value\") %>%\n  left_join(miss_rows, by = c(\".id\", \"var\")) %>%\n  ggplot(aes(x = value, y = .imp, colour = miss)) +\n  geom_point(pch = 1) +\n  scale_colour_manual(values = c(\"dodgerblue3\", \"firebrick3\")) +\n  facet_grid(~var, scales = \"free_x\") +\n  panel_border() +\n  theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/distribution-plot-1.png){fig-align='center' width=715}\n:::\n:::\n\n\n## Running an analysis on the imputed data\n\nRunning the same analysis repeatedly on the imputed data is a fairly straightforward task. The function `dunnart_analyse()` below does this. The actual work is in the line `res <- map(obj$imputations, fn)` which calls a provded function on each imputation and returns the result as a list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunnart_analyse <- function(obj, fn) {\n  stopifnot(inherits(obj, \"dunnart\"))\n  stopifnot(is.function(fn))\n\n  res <- map(obj$imputations, fn)\n  class(res) <- \"dunnart_analysis\"\n  res\n}\n```\n:::\n\n\nAs an example, let's fit a regression model to our imputed data to predict `chl` from all other variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_model <- dunnart_analyse(\n  imp,\n  \\(dat) lm(chl ~ age + bmi + hyp, data = dat)\n)\n```\n:::\n\n\n## Pooling imputations using Rubin's rules\n\nOnce repeated analyses on each imputed dataset have been done, the results need to be combined into a single output. This is done using Rubin's rules, as described in e.g. @rubin1996multipleimputation18. The pooled point estimate is the mean of the estimates from each dataset, and the variance of the pooled estimate is the mean of the variances from each dataset plus $(m+1)/m$ times the between-imputation variance. There are some additional rules to derive the appropriate degrees of freedom for a *t* distribution but in this case we will keep things simple and just use a large-sample Normal approximation.\n\nThe function below implements this, taking advantage of the `broom::tidy()` function to obtain a data frame of estimates and standard errors for each model parameter. In principle a different function could be supplied (e.g. from the `emmeans` or `marginaleffects` package) to obtain a data frame of estimates and standard errors of any estimand of interest from a model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunnart_pool <- function(obj, tidy_fn = broom::tidy, conf_level = 0.95) {\n  stopifnot(inherits(obj, \"dunnart_analysis\"))\n  stopifnot(is.function(tidy_fn))\n\n  # apply the tidier function to each imputation dataset. this should return\n  # a data frame for each analysis output.\n  tidy_analysis <- bind_rows(\n    map(obj, tidy_fn),\n    .id = \".imp\"\n  )\n\n  # number of imputed datasets (needed for Rubin's rules)\n  m <- length(obj)\n\n  # multiplier for confidence interval, e.g. 1.96 for 95% CI\n  ci_mult <- qnorm(0.5 + 0.5*conf_level)\n\n  # apply Rubin's rules and compute CIs and p-values\n  tidy_analysis %>%\n    summarise(\n      std.error = sqrt(mean(std.error^2) + (m+1)/m * sd(estimate)^2),\n      estimate = mean(estimate),\n      .by = term\n    ) %>%\n    relocate(std.error, .after = estimate) %>%\n    mutate(\n      statistic = estimate / std.error,\n      p.value = 2*pnorm(-abs(statistic)),\n      conf.low = estimate - ci_mult*std.error,\n      conf.high = estimate + ci_mult*std.error\n    )\n}\n```\n:::\n\n\nWe can apply this to the regression model we fit earlier to get a table of pooled model parameters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndunnart_pool(example_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 7\n  term        estimate std.error statistic   p.value conf.low conf.high\n  <chr>          <dbl>     <dbl>     <dbl>     <dbl>    <dbl>     <dbl>\n1 (Intercept)   -70.0      66.4     -1.05  0.291      -200.        60.1\n2 age            47.7      10.9      4.37  0.0000122    26.3       69.1\n3 bmi             7.12      2.32     3.07  0.00213       2.58      11.7\n4 hyp            -9.92     19.8     -0.502 0.616       -48.7       28.8\n```\n:::\n:::\n\n\nThis is very similar to the results from the complete case analysis, which is reassuring:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbroom::tidy(lm(chl ~ age + bmi + hyp, data = nhanes), conf.int = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 7\n  term        estimate std.error statistic p.value conf.low conf.high\n  <chr>          <dbl>     <dbl>     <dbl>   <dbl>    <dbl>     <dbl>\n1 (Intercept)   -81.0      61.8     -1.31  0.222    -221.        58.8\n2 age            55.2      14.3      3.86  0.00383    22.9       87.5\n3 bmi             7.07      2.05     3.44  0.00736     2.42      11.7\n4 hyp            -6.22     23.2     -0.268 0.794     -58.7       46.2\n```\n:::\n:::\n\n\n## References\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}